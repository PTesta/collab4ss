%        File: collab4ss.tex
%     Created: Tue Feb 22 02:00 PM 2011 C
% Last Change: Tue Feb 22 02:00 PM 2011 C
%
\documentclass[]{article}

\usepackage{hyperref}

\author{Mark M. Fredrickson \and Paul F. Testa} % \and you!
\title{Collaboration for Social Scientists, or Software is the Easy Part}
\begin{document}

\maketitle
\section{Collaboration Basics}

% text files/documents of simple structure
% sideband communication (``Hey! I'm working on that!'')
% place in context of other articles in TPM

In this article, we consider two different modes of collaboration: synchronous
and asynchronous. When working synchronously, contributors are both working on
\emph{the same portions of the research at the same time}. We provide some
suggestions for maximizing time spent working together. Of course, virtually
any research project will require collaborators to spend time working on
either different portions of the project or working on the same sections but
at different times. We label this form of collaboration asynchronous.
Asynchronous collaboration requires more careful attention to dividing labor,
and we spend more time providing software solutions in this domain.

\section{Synchronous Collaboration}

While it might appear collaborators at the same institution or who can
frequently meet face to face will benefit from synchronous collaboration
techniques, many of these techniques rely on networked computers or can be
applied over video chat or speaker phone.

We begin by importing some techniques from software engineering. In recent
years, so-called ``Agile'' programming and project management aproaches to
software engineering have become popular, especially at start ups and younger
development shops. Many techniques fall under the umbrella of ``Agile''
methods, including suggestions for organizing teams, minimizing unnecessary
meetings, and communicating frequently changing client requests. While social
scientists could benefit from these suggestions, we tend to be our own clients
and work in smaller teams than programmers. One technique we do think would be
of benefit to social scientists would be the concept of \emph{Pair
Programming,} sometimes also called ``eXtreme Programming'' (XP). Pair
programming places two programmers at the same computer: one screen, one
keyboard, two heads. One programmer takes the lead to write software, while
the second provides suggestions, acts as a sounding board, catches errors, and
questions assumptions made by the first programmer. 

While it may sound wasteful to place two collaborators in front of a single
computer and have them both focus on the same task, the technique can lead to
\emph{more} code being written and \emph{higher quality} software as well. The
key insight is that typing is rarely the bottleneck for producing code. Having
a second person on hand to help with the concepts, design, and implementation
cuts down on time spent chasing dead-ends or time wasted on simple bugs.
If you have spent several hours on a problem only to realize your mistake
while explaining the problem to someone, you will see the immediate benefits
of pair programming. 

In practice, pair programming need not have both subjects staring at the same
screen at the same time. One programmer may be writing code, while the other
looks into API documentation, writes unit tests, or provides documentation,
but is immediately available to support the first programmer. Additionally,
collaborators need not be in the same physical space. There are several tools
for real-time co-editing of documents. Wikipedia provides a fairly detailed
list of \href{http://en.wikipedia.org/wiki/Collaborative_real-time_editor}{collaborative real-time
editors}. All of these editors allow multiple authors to simultaneously edit
documents, which may even be a useful feature to pair programmers in the same
physical space. Since this issue of TPM is strongly encouraging learning and
using a text editor, you may wish to favor editors that allow for simultaneous
editing. At a minimum, \href{http://www.gnu.org/software/screen/}{GNU Screen}
provides an immediate solution for Emacs and VIM users who wish to pair program.
More advanced uses may require a editor plugin or separate editor.

In addition to managing file editing, some real time editors also facilitate
verbal communication. Of course, if your editor does not immediately provide
this service, a call via \href{http://www.skype.com}{Skype} or
\href{http://chat.google.com}{Google Chat} can fulfill communication needs. Of
course, these tools can also be of use to collaborators, even they forgo the
pair programming model.
% pair programming
% other agile methods
% screen & google docs
% irc/aim/jabber

\section{Asynchronous Collaboration}
% dropbox/shared files
% wiki

While shared files solve the problem of all collaborators having
access to common resources, simple file servers provide no guarantee that
collaborators will not unintentionally overwrite each others changes. Consider
for example the following scenario, both you and your collaborator are working
on the same LaTeX file. You are editing the abstract, while your partner
changes a few lines in the conclusion. You save your work to the shared area,
while unknown to you, your partner saved her work only a few minutes before.
Even though you were working in an entirely different part of the file, your
changes overwrite those of your partner, silently dropping her work and
reverting back to the old conclusion. Developed for software engineering,
version control systems are designed to address this need, allowing multiple
authors to work on documents and safely merge change. 

% Nils' SVN stuff here.

% make files to explicitly state dependences

While version control systems will keep track of changes and make sure the
source is in a consistent state,  % blah, write this better
source code alone (and here we include things such as .tex files and data),
does not completely describe \emph{how} to create the research. Consider, for
example, creating a figure for a paper. Being a good collaborator, you take
the time to write the figure generating code in \texttt{figure.R} and insert
it into the main \latex file using
\texttt{\\includegraphics}. The figure relies on data in \texttt{data.csv} and
some code in \texttt{models.R}. While it is straightforward for the original
author to create this graphic, will it be obvious to others in the project
that if either the data or models change, the figure should also change? For
lengthy projects, even the original author may forget which files depend on
others.

Again borrowing for software engineering, we suggest the use of build files to
solve this problem. Build files explicitly state dependencies between files
and explain how to generate artifacts, such as PDF files. As an added benefit,
build files automate the creation of artifacts and ensure that files are built
in the proper order. Most importantly, build files ensure that artifacts are
updated when source documents, including data, change. Returning to the figure
example above, we could notate the necessary conditions for updating the
figure and the main PDF with the following GNU \texttt{Makefile}\footnote{We
use the classic and widely available GNU \texttt{make} system, but other build
systems exist. Some of these systems, for example \texttt{Rake} for Ruby,
allow more programming and customization within the build scripts. Your team
may benefit from this extended functionality}:

\begin{verbatim}

paper.pdf: figure.pdf paper.tex
  latexmk -pdf paper.tex

figure.pdf: figure.R data.csv
  R --silent --file = figure.R

\end{verbatim}

The unindented lines indicate \emph{targets}, with a list of dependencies
after the colon and a build command on the following indented line.
The \texttt{make} command checks each target and compares the
time stamp on the target with the time stamp on each dependency. If any
dependency is newer than the target, the dependency is rebuilt using its
command (perhaps recursively building further dependencies) and then builds
the target using its command. For example, if \texttt{data.csv} is updated,
\texttt{make} will automatically rebuild \texttt{figure.pdf} before rebuilding
\texttt{paper.pdf}.

Using a \texttt{Makefile} simplifies the amount of knowledge any individual on
the team has to have regarding creating artifacts. Instead of having to
remember and manually implement the build process, all a collaborator has to
do is type \texttt{make} at the command line and he will be certain to have a
properly built version of an artifact, say a PDF document.

To some degree, literate programming tools, such as \texttt{Sweave}, minimize
the need establish a clear dependency tree in a build script. \texttt{Sweave}
chunks take the place of
having separate files for loading and transforming data, building models, and
generating figures. Since files are evaluated top-down, there is an implicit
dependency structure, with later chunks depending on earlier chunks. In order
to weave the file, all chunks are rebuilt, guaranteeing any changes in early
code chunks flow downstream.

While we are heavy users of \texttt{Sweave}, we still think explicit build
scripts have a role to play. First, certain computations can be time
consuming, but do not need to be frequently updated. Simulations and
boostrapping within a \texttt{Sweave} document increase the time from making
an edit (perhaps to the text) and final output as a PDF. Writing these
computations in separate \texttt{.R} files eliminates the need to rerun the
computations when no code or data has changed.\footnote{We are aware of caching
mechanisms for \texttt{Sweave} chunks, but we are concerned that these systems
do not include specific dependency management and therefore still require more
rebuilding than is necessary with explicit build scripts.} Second, even when
using a single \texttt{Sweave} file to merge text and code, projects of a
reasonable size will include additional files, especially data. These files
may have their own build steps or simply be dependencies for the
\texttt{Sweave} file. Encapsulating these relationships in a build script is
still useful, even when using \texttt{Sweave}. Finally, even when using
\texttt{Sweave}, your team may wish to split up the work into different files
for logical or practical reasons. While version control systems are powerful
tools, sometimes the best way to work with collaborators is to divide the task
into separate tasks and each work in a different file. Build scripts help with
merging the separate files into a unified whole.


\section{Conclusion}

% good collaboration leads to reproducible research
% ``collaborating with replicators'' or something like that

\section{Further Reading}

% TODO appendix and a bib file
\end{document}


